<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml">  <head>    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />    <title>My First Service</title>    <link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.9.0/themes/base/jquery-ui.css" />    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>    <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.9.2/jquery-ui.min.js"></script>    <script>      // Enable the tabs for perl/python code snippets      $(function() {         $("#translate_dna").tabs();         $("#translate").tabs();         $("#translate_import").tabs();         $("#translate_impl").tabs();	 });    </script>  </head>  <body>    <h1>My First Service</h1>    <h2>Introduction</h2>    <p>We will begin by defining a simple service that performs a very basic      task: translate a string of DNA into the corresponding protein characters.      <br />    </p>    <p>We assume here that you have either constructed a development container      and have sourced its user-env file, or you are operating using a pre-built      KBase deployment and have sourced its user-env file.</p>    <h2>Creating and Compiling the Service Definition<br />    </h2>    <p>To begin we need to define the interface to the service. It will ingest a      string of DNA characters and emit a string of protein characters. We use      the <tt>string</tt> type in the type language:</p>    <pre>module MyFirstService {<br />    typedef string DNAString;<br />    typedef string ProteinString;<br />    funcdef translate_dna(DNAString dna) returns (ProteinString prot);<br />};<br /><br /></pre>    <p>Create a file my_service.spec that contains the text above, and run the      type compiler to generate output:</p>    <p></p>    <pre>$ <strong>compile_typespec --psgi service.psgi my_service.spec my_service</strong>my_service.spec: module MyFirstService service MyFirstService</pre>    <p>This will generate the service code in the directory specified as the      last argument:</p>    <pre>$ <strong>ls my_service</strong>MyFirstServiceClient.js	MyFirstServiceClient.py	MyFirstServiceImpl.py	MyFirstServiceServer.pyMyFirstServiceClient.pm	MyFirstServiceImpl.pm	MyFirstServiceServer.pm	service.psgi<br /></pre>    <p>Note that the files created are named using the module name defined in      the interface document. <br />    </p>    <p>The files created include client libraries in Perl, Python, and      Javascript (MyFirstServiceClient), server interface libraries in Perl and Python      (MyFirstServiceServer), implementation files for Perl and Python (MyFirstServiceImpl), and a      service startup program (service.psgi).</p>    <h2>Starting the Service<br />    </h2>    <p>At this stage we have a complete service, although it does not do      anything useful. We can still start a server to host the service, however.      For this we will use the <code>plackup</code> command that is part of the      installed Perl runtime code in the KBase environment:</p>    <pre>$ <strong>plackup --listen :9999 service.psgi</strong><br />HTTP::Server::PSGI: Accepting connections at http://0:9999/<br /></pre>    <p>The <code>--listen</code> parameter defines the TCP port that the      service will listen on. Don't forget to include the colon before the port      number.</p>    <p> A python development server can be started by executing the MyFirstServiceServer.py file, with the --port parameter to specify a port.</p>    <pre>$ <strong>python MyFirstServiceServer --port 9999</strong><br />Listening on port 9999<br /></pre>    <h2>Invoking the Service<br />    </h2>    <p>Now we need to invoke the service. The type compiler is able to generate      command-line programs that invoke service routines that have scalar      arguments. You can generate these by adding the <code>--scripts </code>flag      to the compiler:</p>    <pre>compile_typespec --scripts my_service --psgi service.psgi my_service.spec my_service<br /></pre>    <p></p>    <pre>$ <strong>ls my_service</strong>MyFirstServiceClient.js	MyFirstServiceClient.py	MyFirstServiceImpl.py	MyFirstServiceServer.py	simple_translate_dna.plMyFirstServiceClient.pm	MyFirstServiceImpl.pm	MyFirstServiceServer.pm	service.psgi		translate_dna.pl</pre>    <p>Note we have two new files, translate_dna.pl and simple_translate_dna.pl.      Disregard translate_dna.pl for the moment - it is a skeleton for a      CDM-style command line script that we won't further investigate. If you      look at simple_translate_dna.pl you will find a script that expects to get      a single parameter, a DNA string, and prints the JSON form of the output      (this is currently quite crude but not in its final form):</p>    <p></p>    <pre>$ <strong>cd my_service<br /></strong>$ <strong>perl simple_translate_dna.pl <br /></strong>Usage: translate_dna [--port port] [--url url] dna</pre>    <p>It also expects to receive an option that defines the location of the      service it should use. This can take the form of either a full service URL      or a port number. If you use a port number it expects to find the service      on the local machine. We can try this now. Start the service using plackup      as described above (it is useful to do this in a separate window), and      then run the translation script:</p>    <pre>$ <strong>perl simple_translate_dna.pl --port 9999 ccctag</strong><br />[null]<br /></pre>    <p>Note that we don't receive a valid return. This makes sense, as we have      not yet implemented the service.</p>    <p>In your window where plackup is running you will see a log of this      request:</p>    <p></p>    <pre>127.0.0.1 - - [12/Dec/2012:07:35:29 -0800] "POST / HTTP/1.1" 200 33 "-" "JSON::RPC::Client/0.93 beta libwww-perl/6.04"</pre>    <h2>Implementing the Service Functionality</h2>    <p>We may now implement the service itself. Open MyFirstServiceImpl.pm       (MyFirstServiceImpl.py for Python) in an      editor. This module is invoked by the service handling code when a request      for a service method is received. Each service method is represented by a      function in the implementation file. You will find the translation routine      to look something like this:</p>    <div id="translate_dna">      <ul>	<li><a href="#translate_dna_perl">Perl</a></li>	<li><a href="#translate_dna_python">Python</a></li>      </ul>      <div id="translate_dna_perl"><pre>sub translate_dna{    my $self = shift;    my($dna) = @_;    my @_bad_arguments;    (!ref($dna)) or push(@_bad_arguments, "Invalid type for argument \"dna\" (value was \"$dna\")");    if (@_bad_arguments) {        my $msg = "Invalid arguments passed to translate_dna:\n" . join("", map { "\t$_\n" } @_bad_arguments);        Bio::KBase::Exceptions::ArgumentValidationError-&gt;throw(error =&gt; $msg,                                                               method_name =&gt; 'translate_dna');    }    my $ctx = $MyFirstServiceServer::CallContext;    my($prot);    #BEGIN translate_dna    #END translate_dna    my @_bad_returns;    (!ref($prot)) or push(@_bad_returns, "Invalid type for return variable \"prot\" (value was \"$prot\")");    if (@_bad_returns) {        my $msg = "Invalid returns passed to translate_dna:\n" . join("", map { "\t$_\n" } @_bad_returns);        Bio::KBase::Exceptions::ArgumentValidationError-&gt;throw(error =&gt; $msg,                                                               method_name =&gt; 'translate_dna');    }    return($prot);}<br /></pre>      </div>      <div id="translate_dna_python"><pre>    def translate_dna(self, dna):        # self.ctx should be set by the wsgi application class        # return variables are: prot        #BEGIN translate_dna        #END translate_dna        if not isinstance(prot, basestring):            raise ValueError('Method translate_dna return value prot is not type basestring as required.')        # return the results        return [ prot ]</pre>      </div>    </div>    <p>There is a lot of boilerplate in there that you need not understand (it      is type checking code). The key part is this pair of comments:</p>    <pre>    #BEGIN translate_dna    #END translate_dna</pre>    <p></p>    <p>Your code will go in between the comments. Leave the comments in place -      they are used by the type compiler to retain your code in the file when      the compiler is rerun. The DNA option appears as the variable <code>$dna</code>.      The return value will be placed into the variable <code>$prot.</code>      These names are taken directly from the funcdef statement in your service      specification file.<br />    </p>    <p>We will use a simple translation module; the Perl and Python code for this is in the      Appendix. Copy and paste the code from the appendix into a file called      trans.pm (trans.py) and place that file in the my_service directory next to the other      compiler-generated files.</p>    <p>Our implementation of the translation code itself is trivial:</p>    <div id="translate_impl">      <ul>	<li><a href="#translate_impl_perl">Perl</a></li>	<li><a href="#translate_impl_python">Python</a></li>      </ul>      <div id="translate_impl_perl">    <pre>    #BEGIN translate_dna    $prot = translate($dna);    #END translate_dna<br /></pre>      </div>      <div id="translate_impl_python">    <pre>        #BEGIN translate_dna        prot = translate(dna)        #END translate_dna    </pre>      </div>    </div>    <p>However, we do need to include the translation module. Near the top of      the implementation file you will find a pair of comments:</p>    <pre>#BEGIN_HEADER#END_HEADER<br /></pre>    <p>Code placed between these comments will be retained across compiles.      Place a use statement for our translation utility module there:<br />    </p>    <div id="translate_import">      <ul>	<li><a href="#translate_import_perl">Perl</a></li>	<li><a href="#translate_import_python">Python</a></li>      </ul>      <div id="translate_import_perl">    <pre>#BEGIN_HEADERuse trans;#END_HEADER<br /></pre>      </div>      <div id="translate_import_python"><pre>#BEGIN_HEADERfrom trans import translate#END_HEADER</pre>      </div>    </div>    <p>Kill (^C) and restart your plackup session so that it picks up the new      implementation code. We may now test the service:</p>    <pre>$ <strong>perl simple_translate_dna.pl --port 9999 ATGACAGCGCAAGAAAAACTCTACCAACTAATTCAAACTCTGCCAGAGA</strong>["MTAQEKLYQLIQTLPE"]</pre>    <pre></pre>    <pre></pre>    <pre></pre>    <pre></pre>    <p>We see that we have received a single item from the call, and it is a      reasonable protein translation of that DNA string.</p>    <h2>What Next?</h2>    <ul>      <li>For a real production KBase service we would generate the code in a        namespace under Bio::KBase somewhere, and we would place the files into        the module directory according to the KBase coding standards. The type        compiler would be invoked from the makefile using syntax like</li>    </ul>    <pre>SERVICE_NAME = MyFirstService<br />compile_typespec <br />	-impl Bio::KBase::$(SERVICE_NAME)::Impl \<br />	-service Bio::KBase::$(SERVICE_NAME)::Service \	-client Bio::KBase::$(SERVICE_NAME)::Client \	-js $(SERVICE_NAME) \<br />	-py $(SERVICE_NAME) \<br />	my_service.spec lib<br /></pre>    <ul>      <li>We would include documentation in the service specification document,        which would be propagated to the generated code.</li>      <li>If we were implementing a service that we expected to be called many        times with a large amount of data, we would define an interface where        bulk requests were accepted. For instance, in the DNA translation        service it might make sense to allow the translation of multiple strings        of DNA in one call. The corresponding funcdef might look like this:<br />        <code>funcdef translate_dna_strings(list&lt;DNAString&gt; dna_list)          returns (list&lt;ProteinString&gt; prot_list)</code><br />      </li>    </ul>    <pre></pre>    <h2>Appendix: Simple Translation Module<br />    </h2>    <div id="translate">      <ul>	<li><a href="#translate_perl">Perl</a></li>	<li><a href="#translate_python">Python</a></li>      </ul>      <div id="translate_perl">    <pre>sub translate {    my($dna) = @_;    my($i, $j, $ln);    my($x, $y);    my($prot);    my $code = &amp;standard_genetic_code();    $ln = length($dna);    $prot = "X" x ($ln/3);    $dna =~ tr/a-z/A-Z/;    for ($i=0,$j=0; ($i &lt; ($ln-2)); $i += 3,$j++) {        $x = substr($dna,$i,3);        if ($y = $code-&gt;{$x}) {            substr($prot,$j,1) = $y;        }    }    if (($start) &amp;&amp; ($ln &gt;= 3) &amp;&amp; (substr($dna,0,3) =~ /^[GT]TG$/)) {        substr($prot,0,1) = 'M';    }    return $prot;}sub standard_genetic_code {    my $code = {};    $code-&gt;{"AAA"} = "K";    $code-&gt;{"AAC"} = "N";    $code-&gt;{"AAG"} = "K";    $code-&gt;{"AAT"} = "N";    $code-&gt;{"ACA"} = "T";    $code-&gt;{"ACC"} = "T";    $code-&gt;{"ACG"} = "T";    $code-&gt;{"ACT"} = "T";    $code-&gt;{"AGA"} = "R";    $code-&gt;{"AGC"} = "S";    $code-&gt;{"AGG"} = "R";    $code-&gt;{"AGT"} = "S";    $code-&gt;{"ATA"} = "I";    $code-&gt;{"ATC"} = "I";    $code-&gt;{"ATG"} = "M";    $code-&gt;{"ATT"} = "I";    $code-&gt;{"CAA"} = "Q";    $code-&gt;{"CAC"} = "H";    $code-&gt;{"CAG"} = "Q";    $code-&gt;{"CAT"} = "H";    $code-&gt;{"CCA"} = "P";    $code-&gt;{"CCC"} = "P";    $code-&gt;{"CCG"} = "P";    $code-&gt;{"CCT"} = "P";    $code-&gt;{"CGA"} = "R";    $code-&gt;{"CGC"} = "R";    $code-&gt;{"CGG"} = "R";    $code-&gt;{"CGT"} = "R";    $code-&gt;{"CTA"} = "L";    $code-&gt;{"CTC"} = "L";    $code-&gt;{"CTG"} = "L";    $code-&gt;{"CTT"} = "L";    $code-&gt;{"GAA"} = "E";    $code-&gt;{"GAC"} = "D";    $code-&gt;{"GAG"} = "E";    $code-&gt;{"GAT"} = "D";    $code-&gt;{"GCA"} = "A";    $code-&gt;{"GCC"} = "A";    $code-&gt;{"GCG"} = "A";    $code-&gt;{"GCT"} = "A";    $code-&gt;{"GGA"} = "G";    $code-&gt;{"GGC"} = "G";    $code-&gt;{"GGG"} = "G";    $code-&gt;{"GGT"} = "G";    $code-&gt;{"GTA"} = "V";    $code-&gt;{"GTC"} = "V";    $code-&gt;{"GTG"} = "V";    $code-&gt;{"GTT"} = "V";    $code-&gt;{"TAA"} = "*";    $code-&gt;{"TAC"} = "Y";    $code-&gt;{"TAG"} = "*";    $code-&gt;{"TAT"} = "Y";    $code-&gt;{"TCA"} = "S";    $code-&gt;{"TCC"} = "S";    $code-&gt;{"TCG"} = "S";    $code-&gt;{"TCT"} = "S";    $code-&gt;{"TGA"} = "*";    $code-&gt;{"TGC"} = "C";    $code-&gt;{"TGG"} = "W";    $code-&gt;{"TGT"} = "C";    $code-&gt;{"TTA"} = "L";    $code-&gt;{"TTC"} = "F";    $code-&gt;{"TTG"} = "L";    $code-&gt;{"TTT"} = "F";    return $code;}1;<br /></pre>      </div>      <div id="translate_python"><pre>"""Python version of the KBase DNA translation example code"""code = { "AAA" : "K",         "AAC" : "N",         "AAG" : "K",         "AAT" : "N",         "ACA" : "T",         "ACC" : "T",         "ACG" : "T",         "ACT" : "T",         "AGA" : "R",         "AGC" : "S",         "AGG" : "R",         "AGT" : "S",         "ATA" : "I",         "ATC" : "I",         "ATG" : "M",         "ATT" : "I",         "CAA" : "Q",         "CAC" : "H",         "CAG" : "Q",         "CAT" : "H",         "CCA" : "P",         "CCC" : "P",         "CCG" : "P",         "CCT" : "P",         "CGA" : "R",         "CGC" : "R",         "CGG" : "R",         "CGT" : "R",         "CTA" : "L",         "CTC" : "L",         "CTG" : "L",         "CTT" : "L",         "GAA" : "E",         "GAC" : "D",         "GAG" : "E",         "GAT" : "D",         "GCA" : "A",         "GCC" : "A",         "GCG" : "A",         "GCT" : "A",         "GGA" : "G",         "GGC" : "G",         "GGG" : "G",         "GGT" : "G",         "GTA" : "V",         "GTC" : "V",         "GTG" : "V",         "GTT" : "V",         "TAA" : "*",         "TAC" : "Y",         "TAG" : "*",         "TAT" : "Y",         "TCA" : "S",         "TCC" : "S",         "TCG" : "S",         "TCT" : "S",         "TGA" : "*",         "TGC" : "C",         "TGG" : "W",         "TGT" : "C",         "TTA" : "L",         "TTC" : "F",         "TTG" : "L",         "TTT" : "F"         }def translate( dna ):    dna = dna.upper()    prot = ""    for i in range( len(dna)/3 ):        x=dna[ (i * 3):(i * 3) + 3 ]        prot += code.get(x,"X")    return prot</pre>      </div>    </div>  </body></html>