<h1>HTTP Header Extensions for KBase Messaging</h1>
<p>We define a set of HTTP headers that the standard KBase services interpret to provide advanced capabilities to clients requiring them.<br />
<p>The time required to service an arbitrary KBase request may vary wildly based on the type of service, the type of request, the load on the servers, etc. If the time taken to service a request grows past certain thresholds we begin to see problems appear for our clients that are not directly related to the KBase service - proxy servers may time out, client libraries may time out, etc. <br />
<p>In order to handle these issues we define an interface that allows clients to precisely define the timeout behavior they expect from the KBase.&nbsp;
<h2>Request Behavior<br /></h2>
<p>Let us begin by dissecting a typical exchange between a client and a KBase server. The client is making a request to the GenomeAnnotation service to annotate a genome. The client is using the Perl binding of the service as generated by the KBase service compiler:
<pre>$annotated_genome = $anno_service-&gt;annotate_genome($raw_genome)<br /></pre>
<p>Here, $raw_genome is a data structure containing the name of the genome, some other metadata, and the contigs of the genome. The data structure is defined by the type specification document for the service.
<p>The call made to the service is encoded as a JSONRPC over HTTP request:
<pre>POST /services/genome_annotation HTTP/1.1<br />TE: deflate,gzip;q=0.3<br />Connection: TE, close<br />Accept: application/json<br />Host: bio-data-1.mcs.anl.gov<br />User-Agent: JSON::RPC::Client/0.93 beta libwww-perl/5.834<br />Content-Length: 616199<br />Content-Type: application/json<br /><br />{&quot;params&quot;:[{&quot;scientific_name&quot;:&quot;Buchnera aphidicola&quot;,&quot;domain&quot;:&quot;B&quot;,&quot;contigs&quot;:[{&quot;dna&quot;:&quot;ttaa<br />[etc]<br /></pre>
<p>When the server receives this request, it locates the appropriate service object (generated by the type compiler from the type specification document for the service), parses the parameters, and invokes the method. When the method completes, the results are converted to JSON and returned as the body of the HTTP response:<br />
<pre>HTTP/1.1 200 <br />Server: nginx/1.0.11<br />Date: Tue, 04 Sep 2012 21:28:52 GMT<br />Content-Type: application/json<br />Connection: close<br />Content-Length: 1063634<br /><br />{&quot;version&quot;:&quot;1.1&quot;,&quot;result&quot;:[{&quot;scientific_name&quot;:&quot;Buchnera aphidicola&quot;,&quot;contigs&quot;:[{&quot;dna&quot;:&quot;ttaa<br />[etc]<br /></pre>
<p>The annotation of <span style="font-style: italic;">Buchnera </span>runs quickly, in just a minute or two. Consider however the annotation of a large eukaryotic genome, or the FIGfam analysis of a large metagenomic sample. These calls could take tens of minutes to tens of hours to perform. During this time there are many possibilities for timeouts to occur that may abort the computation:<br />
<ul><li>If the client library is not configured to extend its default timeouts, the client could terminate the request early.<li>If the user was running over a wide-area link, a disruption in the network between the client and server could terminate the TCP connection.<li>If the user is required to use a web proxy to gain access to external services, the proxy may impose a fairly short (we have seen three minutes) timeout on any request.<li>Within the KBase service infrastructure a particular frontend may (due to misconfiguration or policy to keep the number of active connections to a reasonable level) impose a message timeout.</ul>
 We clearly need a better way.<br />
<h2>Extending the Request</h2>
<p>Given the limitations of HTTP requests as described above, any solution requires that the time spent processing the HTTP request be bounded to a fairly short interval. When we need to handle application requests that will take arbitrarily long amounts of time to process, we must move to an asynchronous communication pattern.
<p>The simplest approach from a protocol point of view is to merely require that any KBase service not have any method that takes longer than some fixed amount of time to execute. Services that need longer to execute will need to implement their own job queuing mechanism, returning to the client a job identifier that may then be later queried for execution status and to retrieve output data.
<p>While that mechanism works well for applications like genome application or model building that expect calls to run for hours, it is less applicable to services like the Invocation Service that backs up the IRIS site, or the <a name="Central Store724">Central Store</a> database service. Here, calls to services will typically take fractions of a second to tens of seconds to run, but there are valid and useful calls that can take significantly longer. We wish to transparently support these longer calls in a way that does not overtax the service and that is not susceptible to the request-killers discussed above. 
<p>In order to accomplish this, we first introduce a layer of asynchrony into the service invocations. We place a request queue between the incoming service requests and the programs that do the service-specific processing of the requests. With such a request queue in place, it is now straightforward to add a service timeout mechanism that is implemented by the HTTP request handling code that wraps the actual service invocation.&nbsp;
<p>We allow the client to configure the behavior of the service timeout with the addition of two new HTTP headers:
<ul><li><span style="font-style: italic;">Timeout</span> is the duration in seconds that the service will wait before declaring the request to be timed out.<li><span style="font-style: italic;">Timeout-action</span> is a string that defines the action the service will take when a request is timed out.</ul>
<p>The timeout action can have one of three values. If it is set to &quot;abort&quot;, the service will return a HTTP response with a response code of 504, &quot;Gateway Timeout&quot;. <br />
<p>If it is set to &quot;background&quot;, the service will assign a unique identifier to this request and return a HTTP response with a response code of 308, &quot;Backgrounded&quot;. A URI will be returned to the client in the <span style="font-style: italic;"><a name="Location725">Location</a></span> HTTP response header; this URI may be used to query the status of the backgrounded request and to retrieve the output.&nbsp;
 If it is set to &quot;continue&quot;, and the HTTP server hosting the service supports persistent connections, when a timeout occurs the server will issue a HTTP response with a response code of 100, &quot;Continue&quot;, and the connection is left open. <span style="font-style: italic;">This action will likely not be implemented in the short term.</span>
<br />
<h2>Retrieving Backgrounded Results<br /></h2>
<p>If a request has been backgrounded, it is the responsibility of the client to periodically poll the service to determine the status of the request.&nbsp;
<p>A poll request is performed by sending a GET request to the URI that was returned to the client in the <span style="font-style: italic;"><a name="Location726">Location</a></span> header in the backgrounded response. The server will respond with one of the following response codes:
<ul><li>200 &quot;OK&quot;. The original request has completed. The original response is passed through in the body of this response. The status line that would have originally been returned for that response is encoded in the <span style="font-style: italic;">Warning</span> header as follows:<br /><span style="font-style: italic;">Warning: original response XXX message</span><br /> where XXX is the HTTP response code.<br /><li>404 &quot;Not found&quot;. The request has not yet completed.<li>410 &quot;Gone&quot;. No request was found at the given URI.</ul>
<p>The cached response to the request will linger for an implementation-dependent period of time, or until a DELETE request is made to the background request URI. 
<p> If the client sets the <span style="font-style: italic;">Timeout</span> header of a backgrounded URI GET request to a positive number, and the request has not yet completed, the server will block for that number of seconds awaiting the request to complete. If the request completes in that period the server will return a status code 200. If at the end of that period the request has not completed the server will return a status code 404.
<h2>Implementation Notes</h2>
<p>It is assumed that a message queueing system lies behind compliant server implementations of this protocol. There is a balance to be struck between the long-term reliability of deferred requests and the efficiency with which they may be retrieved. That is, if request results may be buffered in memory it is likely that we may achieve high performance at the cost of potentially large memory utilization and the danger of message loss if the buffering processes crash. A more durable broker may cache the requests and responses on disk at an added overhead. It may well be reasonable for an implementation to span both regimes, buffering in memory for a period of time and switching to disk-based caching if the time taken for a response passes a threshold, under the assumption that a long-running request is more valuable to the user than a brief request (which could be easily repeated).<br />
<h2>Conclusion</h2>
<p>We have defined a mechanism that enables an intelligent client implementation to control the timeout behavior of a compliant web service using a small set of new HTTP headers. Clients may request servers to background long-running requests, and efficiently check for their completion and retrieve the delayed results.
<br />
<h2>References</h2>
<ol><li><a href="http://www.jsonrpc.org/historical/json-rpc-over-http.html" target="_blank">http://www.jsonrpc.org/historical/json-rpc-over-http.html</a>. Defines a mapping of JSONRPC results to HTTP status codes. Document is historical.<li><a href="http://www.jsonrpc.org/specification" target="_blank">http://www.jsonrpc.org/specification</a>. JSON-RPC 2.0 specification.<li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html" target="_blank">http://www.w3.org/Protocols/rfc2616/rfc2616.html</a>. RFC 2616 - Hypertext Transfer <a name="Protocol727">Protocol</a>.<br /></ol>
<p><br />
