<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>auth</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@b2.novalocal" />
</head>

<body style="background-color: white">


<h1 id="Bio::KBase::AuthClient">Bio::KBase::AuthClient</h1>

<pre><code>Client libraries that handle KBase authentication.</code></pre>

<h2 id="Examples:">Examples:</h2>

<dl>

<dt id="Conventional-OAuth-usage-with-Authorization-header-in-http-header:">Conventional OAuth usage with Authorization header in http header:</dt>
<dd>

<pre><code>    my $ua = LWP::UserAgent-&gt;new();
    my $req = HTTP::Request-&gt;new( GET =&gt; $server. &quot;someurl&quot; );

    # Create a KBase client and attach the authorization headers to the
    # request object. Use a &quot;key&quot; and &quot;secret&quot; as the secret, where secret
    # is an RSA private key where the public key has been associated with the
    # username on Globus nexus
    my $ac = Bio::KBase::AuthClient-&gt;new(user_id =&gt; &#39;username&#39;, client_secret =&gt; &#39;secret&#39;);
    unless ($ac-&gt;{logged_in}) {
        die &quot;Client: Failed to login with credentials!&quot;;
    }
    unless ($ac-&gt;sign_request( $req)) {
        die &quot;Client: Failed to sign request&quot;;
    }
    my $res = $ua-&gt;request( $req);
    print $res-&gt;content</code></pre>

</dd>
<dt id="Embedding-a-non-standard-OAuth-token-within-JSON-RPC-message-body:">Embedding a non-standard OAuth token within JSON-RPC message body:</dt>
<dd>

<pre><code>    # The arguments to the method call
    #
    my @args = (&quot;arg1&quot;, &quot;arg2&quot;);

    my $wrapped_params = {
        args =&gt; \@args,
    };

    #
    # The JSONRPC protocol data.
    #
    my $jsonrpc_params = {
        method =&gt; &quot;module.server_call&quot;,
        params =&gt; [$wrapped_params],
    };

    # Use the oauth libraries to create an oauth token using &quot;jsonrpc&quot; as
    # the method, and a digest hash of rpc call parameters as the &#39;url&#39;
    # this construction isn&#39;t recognized anywhere outside of KBase
    # On the server side, to validate the request, you would extract
    # all the components and compute the md5_base64 hash of the
    # contents of $json_call, and then make a call like this
    # $as = Bio::KBase::AuthServer
    # $inf{request_method} = &quot;jsonrpc&quot;;
    # $inf{request_url} = $param_hash
    # if ( $as-&gt;validate_auth_header( $token, %inf)) {
    #         good stuff
    # } else {
    #         bad stuff
    # }
    my $json_call = to_json( $jsonrpc_params);
    my $param_hash = md5_base64( $json_call);

    my $token = $ac-&gt;auth_token( request_method =&gt; &#39;jsonrpc&#39;,
                                 request_url =&gt; $param_hash );
    my $wrapped = { params =&gt; [$json_call, $token],
                    version =&gt; 1.1,
                    method =&gt; &quot;module.method_name&quot; };

    $req-&gt;content( to_json( $wrapped));

    # Sign the http request for oauth
    unless ($ac-&gt;sign_request( $req)) {
        die &quot;Client: Failed to sign request&quot;;
    }
     my $res = $ua-&gt;request( $req);
    printf &quot;Client: Recieved a response: %s\n&quot;, $res-&gt;content;</code></pre>

</dd>
</dl>

<h2 id="Environment">Environment</h2>

<pre><code>   User home directories can contain $auth_rc, which is a JSON formatted file with declarations for authentication information (similar to a ~/.netrc file)
   It should be in the following format:</code></pre>

<p>{ &quot;oauth_key&quot;:&quot;consumer_key_blahblah&quot;, &quot;oauth_token&quot;:&quot;token_blah_blah&quot;, &quot;oauth_secret&quot;:&quot;client_secret_blahblah&quot; }</p>

<h2 id="Instance-Variables">Instance Variables</h2>

<dl>

<dt id="user-Bio::KBase::AuthUser-"><b>user</b> (Bio::KBase::AuthUser)</dt>
<dd>

<p>Contains information about the user using the client. Also the full set of oauth credentials available for this user</p>

</dd>
<dt id="oauth_creds-hash-"><b>oauth_creds</b> (hash)</dt>
<dd>

<p>Contains the hashref to specific oauth credential used for authentication. It is a hash of the same structure as the oauth_creds entries in the Bio::KBase::AuthUser</p>

</dd>
<dt id="logged_in-boolean-"><b>logged_in</b> (boolean)</dt>
<dd>

<p>Did login() successfully return? If this is true then the entry in the user attribute is good.</p>

</dd>
<dt id="error_message-string-"><b>error_message</b> (string)</dt>
<dd>

<p>Most recent error msg from call to instance method.</p>

</dd>
</dl>

<h2 id="Methods">Methods</h2>

<dl>

<dt id="new-consumer_key-key-client_secret-secret-"><b>new</b>([consumer_key=&gt;key, client_secret=&gt;secret])</dt>
<dd>

<p>returns Bio::KBase::AuthClient</p>

<p>Class constructor. Create and return a new client authentication object. Optionally takes arguments that are used for a call to the login() method. By default will check ~/.kbase-auth file for declarations for the consumer_key and client_secret, and if found, will pull those in and perform a login(). Environment variables are also an option and should be discussed.</p>

</dd>
<dt id="login-user_id-someuserid-consumer_key-key-client_secret-secret-user_id-someuserid-password-somepassword-conversation_callback-ptr_conversation_function-return_url-async_return_url-"><b>login</b>( [user_id =&gt; someuserid, consumer_key=&gt;key, client_secret=&gt;secret] | [user_id=&gt;&acirc;&#128;&#157;someuserid&acirc;&#128;&#157;,[password=&gt;&acirc;&#128;&#153;somepassword&acirc;&#128;&#153;] | [conversation_callback =&gt; ptr_conversation_function] | [return_url = async_return_url])&gt;</dt>
<dd>

<p>returns boolean for login success/fail.</p>

<p>If no parameters are given then consumer (key,secret) will be populated automatically from ~/.kbase-auth. Environment variables are also an option.</p>

<p>When this is called, the client will attempt to connect to the back end server to validate the credentials provided. The most common use case will be to pull the consumer_key and client_secret from the environment. You can also specify the user_id and password for authentication - this is only recommended for bootstrapping the use of consumer (key,secret).</p>

<p>If the authentication is a little more complicated there are 2 options - define a function that handles the login interaction (same idea as the PAM conversation function). - if we&acirc;&#128;&#153;re in a web app that needs oauth authentication, then the client browser will need to be redirected back and forth. A return url where control will pass once authentication has completed needs to be provided ( see this diagram for an example). If the return_url is provided, this function will not return.</p>

</dd>
<dt id="sign_request-HTTPRequest-request_object-Bio::KBase::AuthUser-user-"><b>sign_request</b>( HTTPRequest request_object,[Bio::KBase::AuthUser user])</dt>
<dd>

<p>returns boolean</p>

<p>Called to sign a http request object before submitting it. Will push authentication/authorization messages into the HTTP request headers for authentication on the server side. With OAuth 1.0(a) this will be one set of headers, and with OAuth 2.0 it should be a smaller, simpler set of headers This method must be called on a request object to &acirc;&#128;&#156;sign&acirc;&#128;&#157; the request header so that the server side can authenticate the request. Note that different authentication methods have different requirements for a request: 1) username/password requires SSL/TLS for obvious reasons 2) oauth1 uses shared secrets and cryptographic hashes, so the request can be passed in the clear 3) oauth2 using MAC tokens use a shared secret, so the request can be in cleartext 4) oauth2 using Bearer tokens uses a text string as a combination username/password, so it must be over SSL/TLS If the transport protocol violates the requirements of the authentication method, sign_request() will return false and not encode any information in the request header. We can simplify things if we simply settle on options 2 and 3, and rule out options 1 and 4. It is also possible to finesse #1 into a cleartext protocol as well. But #4 (oauth2 bearer tokens) *must* be SSL/TLS. My recommendation is to disallow #4 so that we do not have to require SSL/TLS.</p>

</dd>
<dt id="auth_token-string-URL-Bio::KBase::AuthUser-user-not-yet-implemented-user-consumer-key-secret-for-now-"><b>auth_token</b>( string URL,[Bio::KBase::AuthUser user]) **not yet implemented** (user consumer key/secret for now)</dt>
<dd>

<p>returns string</p>

<p>Returns a base64 encoded authentication token (tentatively based on the XOauth SASL token) that can be used for a single session within a non-HTTP protocol. The URL passed in is used to identify the resource being accessed, and is used in the computation of the hash signature. The url passed to Bio::KBase::AuthServer::validate_auth_token() on the other end of the exchange must be identical. Authentication tokens are also timestamped and intended for a single use. The token is generated from the consumer key and secret, and should not be stored across sessions for re-use (at the very least, it should timeout even if token replay safeguards fail).</p>

</dd>
<dt id="new_consumer-returns-hash-consumer_key-key-client_secret-secret-"><b>new_consumer()</b> returns hash { consumer_key =&gt; key, client_secret =&gt; secret}</dt>
<dd>

<p>This function requests a consumer (key,secret) pair from the user directory that can be used for subsequent authentication. The (key,secret) should be stored in the environment. Note that the key/secret are associated with the account when you generate it - please do not overuse and cause a proliferation of key/secret pairs.</p>

</dd>
<dt id="logout-return_url-async_return_url-"><b>logout</b>([return_url = async_return_url])</dt>
<dd>

<p>returns boolean</p>

<p>Wipe out the auth info, and perform related logout functions. If we are being called in a web app, provide an asynchronous call back URL that the client browser will be redirected to after logout is called - execution will not return if return_url is defined.</p>

</dd>
</dl>


</body>

</html>


