<h1>Processing Identical Genomes</h1>

The KBase is intended as an environmentin which identical genomes,
annotated by distinct groups, can reside and be	compared.  We anticipate
that there willsoon bethousands of "essentially identical" genomes, due
to the rapid increase in sequencing capacity.  We will cover "very similar"
genomesin other tutorials.  This shortdocument will just makecomments
relating to the	use of identical genomes.
<br><br>
So, howdo you know what identical genomes exist withinthe KBase?  You
might start by just running a command like
<br><pre>
      <a href="http://bio-admin-2.mcs.anl.gov/ksite/index.php/developers/api-documentation/cdmi-entity-api/#all_entities_Genome" target='_blank'>all_entities_Genome</a> -f 'md5,scientific_name' | sort -k 2
<br></pre>
which produces output like
<br><pre>
kb|g.2123	001abafe9595720c262f47843d7837f3	Proteus mirabilis HI4320
kb|g.9440	001cd0a84ad3f5184a031fff80b6df62	Pasteurella phage F108
kb|g.3099	00219e734e8d768ee6a8604b50fe82f2	Alistipes shahii WAL 8301
kb|g.392 	00262fed25a37ff8b430d240aa914110	Pseudomonas fluorescens SBW25
kb|g.8843	00262fed25a37ff8b430d240aa914110	Pseudomonas fluorescens SBW25
kb|g.19962	0026a2cbccd1f5db5714082c4c6bae35	Sugarcane streak Egypt virus
kb|g.9347	003169b175a34753e219ae11682ce08a	Myxococcus fulvus
.
.
.
<br></pre>
The command says 
<blockquote>
Give me all genomes.  For each genome give me 3 fields:
<ol>
<li> the id (by default -- you do not have to list it),
<li> the md5 hash value of the contigs that make up the genome, and
<li> the scientific name of the genome.
</ol>
</blockquote>
<br>
Looking at the initial lines of output, it is clear that <i>kb|g.392</i> 
and <i>kb|8843</i> are identical.
<br><br>
The simple command above often suffices to give you information relating
to your needs.  Sometimes you can use a grep to focus the output.  Thus,
<br><pre>
      <a href="http://bio-admin-2.mcs.anl.gov/ksite/index.php/developers/api-documentation/cdmi-entity-api/#all_entities_Genome" target='_blank'>all_entities_Genome</a> -f 'md5,scientific_name' | sort -k 2 | grep E110019
<br></pre>
would produce
<br><pre>
kb|g.9430	0eb6bdaa44b9b24488debd7d7cf3003f	Escherichia coli E110019
kb|g.958 	0eb6bdaa44b9b24488debd7d7cf3003f	Escherichia coli E110019
kb|g.959 	a4a937e222aed004f9778feae4d01f5d	Escherichia coli E110019
<br></pre>
which would indicate that we have three copies of the genome, two of which are identical.
<br><br>
Suppose that you wished to construct a table where each row contained
a set of tab-separated ids for identical genomes. 
This might come in handy in many contexts.  Here is one way to build the table
using a small perl program that invokes the CS-API routines:

<br><pre>

use Bio::KBase;
my $kb  = Bio::KBase->new;
my $csO = $kb->central_store();

my %by_md5;

my $genH = $csO-><a href="http://bio-admin-2.mcs.anl.gov/ksite/index.php/developers/api-documentation/cdmi-entity-api/#all_entities_Genome" target='_blank'>all_entities_Genome</a>(0,100000,['md5']);
foreach my $genome (keys(%$genH))
{
    my $md5 = $genH->{$genome}->{md5};
    push(@{$by_md5{$md5}},$genome);
}

foreach my $md5 (keys(%by_md5))
{
    print join("\t",@{$by_md5{$md5}}),"\n";
}
<br></pre>
The three lines
<br><pre>
use Bio::KBase;
my $kb  = Bio::KBase->new;
my $csO = $kb->central_store();
<br></pre>
are used to get an object (<i>$csO</i>) that offers access to the CS-API.
The line
<br><pre>
    my $genH = $csO-><a href="http://bio-admin-2.mcs.anl.gov/ksite/index.php/developers/api-documentation/cdmi-entity-api/#all_entities_Genome" target='_blank'>all_entities_Genome</a>(0,100000,['md5']);
<br></pre>

asks for access to the <i>md5</i> field for the first up to 100,000
genomes.  This issue of "chunking" the output from the servers is discussed
below.  For now, just think of this line as asking for acces to the <i>md5</i>
values for all of the genomes.

The lines
<br><pre>
    my $md5 = $genH->{$genome}->{md5};
    push(@{$by_md5{$md5}},$genome);
<br></pre>

lead to the construction of <i>%by_md5</i> as a hash with the md5 values
as keys and lists of genomes having the same md5 hashes as the values.
<br><br>
Once the hash is constructed, it is straightforward to dump the lists from
the hash table.
<br><br>
Now let us revisit this issue of getting back "chunks" of the output, rather than
everything all at once.  This avoids overloading the client memory and causes
output to be "streamed" in a much more controlled fashion.  In the case of asking for
all genomes, you could get them all back without doing too much damage.  If you asked
for all Features and their protein sequences, you might well get back a lot of data.  Most
modern machines can absorb hundreds of gigabytes, but as volumes grow it will just
be a lot easier if we implement basic flow control.  With that in mid, we recommend 
using a program like
<br><pre>
use Bio::KBase;
my $kb  = Bio::KBase->new;
my $csO = $kb->central_store();

my %by_md5;

my $next_output = 0;
my $size_chunk  = 100000;
my $genH;
while (($genH = $csO-><a href="http://bio-admin-2.mcs.anl.gov/ksite/index.php/developers/api-documentation/cdmi-entity-api/#all_entities_Genome" target='_blank'>all_entities_Genome</a>($next_output,$size_chunk,['md5'])) && (%$genH))
{
    foreach my $genome (keys(%$genH))
    {
	my $md5 = $genH->{$genome}->{md5};
	push(@{$by_md5{$md5}},$genome);
    }
    $next_output += $size_chunk;
}

foreach my $md5 (keys(%by_md5))
{
    print join("\t",@{$by_md5{$md5}}),"\n";
}
<br></pre>

Well, so far we have discussed the simple issue of how to find out
which genomes are completely identical (i the sense that they have
an identical set of contigs, but probably have differing gene calls
and annotations).
<br><br>
Let us now consider the issue of how to create a correspondence between
genes from two identical genomes.  This is somewhat different than
asking for gene correspondences between very, very similar genomes; in the
case of identical genomes one can detect correspondence based on location.
That is, two genes that have location strings that differ only in the genome 
ids then clearly correspond.  This solves the bulk of the problem, although
there remains the topic of how to handle pairs of protein-encoding genes that
differ only in start location.
<br><br>

So, given two genomes that you know are identical, (say, kb|g.3383 and kb|g.19998),
and you want to see the correspondence between the protein-encoding genes from the two genomes.
<br><br>

You might begin with something like
<br><pre>
    echo 'kb|g.3383'  | <a href="http://bio-admin-2.mcs.anl.gov/ksite/index.php/developers/api-documentation/cdmi-entity-api/#get_entity_Genome" target='_blank'>get_entity_Genome</a> -f md5 
    echo 'kb|g.19998' | <a href="http://bio-admin-2.mcs.anl.gov/ksite/index.php/developers/api-documentation/cdmi-entity-api/#get_entity_Genome" target='_blank'>get_entity_Genome</a> -f md5 
<br></pre>

to verify that the two gnomes are really the same (they should both produce an md5 of "f26f59daae18a385bdfcf89aa6b0bc1c").
<br><br>
Then you might try making a file that contained just the two genome IDs (that is,
a file called <i>genomes</i> that contained
<br><pre>
kb|g.3383
kb|g.19998
<br></pre>
Then try
<br><pre>
	 <a href="http://bio-admin-2.mcs.anl.gov/ksite/index.php/developers/api-documentation/cdmi-api/#genomes_to_fids" target='_blank'>genomes_to_fids</a> peg < genomes |
	 <a href="http://bio-admin-2.mcs.anl.gov/ksite/index.php/developers/api-documentation/cdmi-api/#fids_to_locations" target='_blank'>fids_to_locations</a> | 
	 <a href="http://bio-admin-2.mcs.anl.gov/ksite/index.php/developers/api-documentation/cdmi-api/#fids_to_protein_sequences" target='_blank'>fids_to_protein_sequences</a> -c 2 -fasta=0 |
	 sort -k 4
<br></pre>
to get a 4-column table containing

<br><pre>
         [genome,fid,location,translation]
<br></pre>

sorted on translation.  You can persue this file to locate matches and mismatches and to get
a sense of how well the gene calls match up.
<br><br>
While there is a great deal that can be learned quickly by accessing the data via
command-line tools, what is needed is more control; that probably requires using the
CS-API.
<br><br>
Here is a short program that takes as inut two genome IDs (<i>g1</i> and <i>g2</i>) and prints out
a two column table.  The first column represents a gene in <i>g1</i> that corresponds to the gene in
the second colum from <i>g2</i>.  If one of the columns is empty, then we have a case where a gene
fails to correspond to a gene in the other genome.
<br><br>
We will do a simple program here that just implements the notion that two genes correspond iff they
have identical locations.  This is not a completely trivial notion, since unique KBase IDs have been assigned to
the contigs in each genome.  However, since the key of a <b>Contig</b> is a unique Kbase ID, but
the key of the related <b>ContigSequence</b> is an md5 hash, equivalence of locations is easily computed.
Here is the program:
<br><pre>
use Bio::KBase;
my $kb  = Bio::KBase->new;
my $csO = $kb->central_store();

# First, get the two genomes to be compared.  We assume that they
# have identical md5 hash values.
my($g1,$g2);
my $usage = "Usage: get_corresponding_features Genome1 Genome2";
(
 ($g1 = shift @ARGV) &&
 ($g2 = shift @ARGV)
)
    || die $usage;

# The little routines get_contig_to_md5_mapping gets a hash table
# that maps contig IDs from the first genome to md5 values.
#
# The second routine, get_md5_to_contig_mapping, creates
# a mapping from md5 values to contigs in the second genome.
#
# To map the contig IDs from genome1 to contig values in genome2
# is a 2-step process from contigs1->md5s->contigs2.
#
my $contig_to_md5_1 = &get_contig_to_md5_mapping($csO,$g1);
my $md5_to_contig_2 = &get_md5_to_contig_mapping($csO,$g2);

# Genomes to fids just maps the genome IDs to lists of the
# protein-encoding genes that occur in each of the genomes.
my $gH    = $csO-><a href="http://bio-admin-2.mcs.anl.gov/ksite/index.php/developers/api-documentation/cdmi-api/#genomes_to_fids" target='_blank'>genomes_to_fids</a>([$g1,$g2],['peg']);
my $fids1 = $gH->{$g1};
my $fids2 = $gH->{$g2};

# Now we pick up the locations associated with each of the features
# in each of the genomes.
my $fid_locH1       = $csO-><a href="http://bio-admin-2.mcs.anl.gov/ksite/index.php/developers/api-documentation/cdmi-api/#fids_to_locations" target='_blank'>fids_to_locations</a>($fids1);
my $fid_locH2       = $csO-><a href="http://bio-admin-2.mcs.anl.gov/ksite/index.php/developers/api-documentation/cdmi-api/#fids_to_locations" target='_blank'>fids_to_locations</a>($fids2);

# Now we map string forms of the locations in genome2 to
# feature IDs.
#
my %in2;
foreach my $fid2 (@$fids2)
{
    my $loc2 = $fid_locH2->{$fid2};
    my $loc2_string = join(",",map { join("", $_->[0], "_", $_->[1], $_->[2], $_->[3]) } @$loc2);
    $in2{$loc2_string} = $fid2;
}

# Now try to map the fids from genome 1 to corresponding locations in genome 2 (by
# mapping the contig names in the locations).  If the mapped location is a gene
# in the second genome, we print the pair and record the fact that we matched it.
# If not, we just print a mismatch.
#
my %matched;
foreach my $fid1 (@$fids1)
{
    my $loc1         = $fid_locH1->{$fid1};  
    my $projected_loc = join(",",map { my($contig1,$start,$strand,$ln) = @$_;
	 			       my $contig2 = $md5_to_contig_2->{$contig_to_md5_1->{$contig1}};
			 	       join("",($contig2,"_",$start,$strand,$ln))
                                     } @$loc1
                            );

    my $fid2 = $in2{$projected_loc};
    if ($fid2)
    {
	$matched{$fid2} = 1;
	print "$fid1\t$fid2\n";
    }
    else
    {
	print "$fid1\t\n";
    }
}

# Finally, we display the unmatched fids from the second genome.

foreach my $fid2 (@$fids2)
{
    if (! $matched{$fid2})
    {
	print "\t$fid2\n";
    }
}

sub get_contig_to_md5_mapping {
    my($csO,$g) = @_;

    my $gH = $csO-><a href="http://bio-admin-2.mcs.anl.gov/ksite/index.php/developers/api-documentation/cdmi-api/#genomes_to_contigs" target='_blank'>genomes_to_contigs</a>([$g]);
    my $contigs = $gH->{$g};
    return $csO-><a href="http://bio-admin-2.mcs.anl.gov/ksite/index.php/developers/api-documentation/cdmi-api/#contigs_to_md5s" target='_blank'>contigs_to_md5s</a>($contigs);
}

sub get_md5_to_contig_mapping {
    my($csO,$g) = @_;

    my $gH = $csO-><a href="http://bio-admin-2.mcs.anl.gov/ksite/index.php/developers/api-documentation/cdmi-api/#genomes_to_contigs" target='_blank'>genomes_to_contigs</a>([$g]);
    my $contigs = $gH->{$g};
    my $md5_contig_tuples = $csO-><a href="http://bio-admin-2.mcs.anl.gov/ksite/index.php/developers/api-documentation/cdmi-entity-api/#get_relationship_HasAsSequence" target='_blank'>get_relationship_HasAsSequence</a>($contigs,[],['from_link','to_link'],[]);
    my $md5_contig = {};
    foreach $_ (@$md5_contig_tuples)
    {
	$md5_contig->{$_->[1]->{to_link}} = $_->[1]->{from_link};
    }
    return $md5_contig;
}

<br></pre>

If you run this on a pair of identical genomes (say, the two we gave earlier), you will
see way more mismatches than you might expect.  Many of these are due to differing start calls.
Can you modify the program to map genes iff that are on the same strand and have identical
end locations?
