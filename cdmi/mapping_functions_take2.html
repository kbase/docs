<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
  <title>MD5</title>
</head><body><h1>Mapping Functions Between Sources of Annotations: Take 2</h1>

In another tutorial we outlined an approach to 
<a target="_blank" href="http://kbase.us/index.php/developers/tutorials/towards-a-controlled-vocabulary-of-function/">establishing exchangable annotations based on exemplars</a>.

The approach we illustrate here involves a set of perl programs that invoke 
KBase command-line tools (rather than using the KBase API directly).  In our view
this is a convenient paradigm for problems for which performance is not the big issue.

<h2>"Clean MD5s", "Matched Assertions", and Building a Mapping</h2>

Suppose that we have two sources of annotations: the SEED and another source
of KBase genomes -- say, MicrobesOnLine.  The strategy we illustrate here involves four steps:
<ol>
<li>
First, for the SEED we compute a set of two-tuples containing:
<ol type="a">
<li>an md5 hash value which acts as the ID of a ProteinSequence that may connect
to a set of Features which have been assigned functions, and
</li><li>
a function that is guaranteed to have been assigned to a majority of the Features
with the single ProteinSequence.  
</li></ol>
<br>
You would think that all Features sharing a common protein sequence would have identical
functions, but a substantial amount of inconsistency exists in all of the annotation
collections (including the SEED).  By computing these 2-tuples we have 
accumulated a set of SEED assertions that pass a minimal consistency test.  We call these 
2-tuples (md5,function) <i>clean md5 assertions</i> and think of them
as the <i>atomic assertions of function</i>.  We will accumulate them for two
distinct sources of annotation, and then we will be prepared to reconcile the two sets.
<br><br>
Our main goal in forming these mappings between distinct sources of annotations relates to the construction
of metabolic and regulatory models.  Hence, we will restrict ourselves to accumulating assertions
that relate to functional roles used in construction of models.  Our hope is that, by seeking consistency and
accuracy for annotations relating to these roles, we will lay the foundation for improving the rapidly growing collection
of models (especially those derived automatically annotations).  By restricting the set of functional roles 
we will focus on, we will be limiting the discussion to 2000-2500 functional roles, and this will
allow us to manually evaluate and correct our progress. 
</li><br><li>
So, the second step will be to accumulate clean md5 assertions for a second source - in this case, MOL.
<br><br>
</li><li>The third set is to take the two sets of clean md5 assertions, one from the SEED and one from MOL,
and compute what is essentially the "join".  We build 3-tuples containing
<br><br>
<ol type="a">
<li>a seed-function,
</li><li>an  md5 value for which (seed-function,md5) is a clean md5 assertion from the SEED collection, and
</li><li>an MOL function for which (MOL-function,md5) is a clean md5 assertion from MOL.
</li></ol>
<br>
Each of these 3-tuples represent cases in which the two annotation
sources have provided annotations for a common sequence (or set of
more-or-less consistently annotated instances of the same sequence).
Call such a 3-tuple a <i>matched assertion</i>.
Matched assertions become the raw input to a process of
creating mapping between function annotations in one vocabulary to assertions in a second vocabulary.
</li><br>
  <li>
Finally, we need an approach to integrate the matched assertions into a coherent mapping of function. Consider the case in which you have a set of matched assertions that have a common first member (i.e.,
all of the 3-tuples have a common SEED function).  Then, the set of third members give the different
MOL functions that correspond to these SEED functions.  In the best case, all of the MOL functions are
identical.  Then a simple rule for translating the SEED function to an MOL function can be formulated.</li>
</ol><br>
Now, we can consider an example implementation of the four steps.

<h3>Computing <i>Clean MD5 Assertions</i> for the SEED</h3>
The program to compute SEED clean md5 assertions can be simply cast in Perl.
In this case, we choose a technology in which CS-API commands are invoked using the Perl <i>system</i>
command:
<br><pre>system("<a href="http://kbase.us/index.php/developers/api-documentation/cdmi-api/#all_roles_used_in_models" target='_blank'>all_roles_used_in_models</a> | <a href="http://kbase.us/index.php/developers/api-documentation/cdmi-api/#roles_to_proteins" target='_blank'>roles_to_proteins</a> 2&gt; /dev/null &gt; role.md5.$$";<br>system("<a href="http://kbase.us/index.php/developers/api-documentation/cdmi-api/#proteins_to_fids" target='_blank'>proteins_to_fids</a> &lt; role.md5.$$  2&gt; /dev/null | \<br>        <a href="http://kbase.us/index.php/developers/api-documentation/cdmi-api/#fids_to_genomes" target='_blank'>fids_to_genomes</a> | \<br>        <a href="http://kbase.us/index.php/developers/api-documentation/cdmi-entity-api/#get_relationship_WasSubmittedBy" target='_blank'>get_relationship_WasSubmittedBy</a> -to id | \<br>        grep \"SEED\$\" | \<br>        <a href="http://kbase.us/index.php/developers/api-documentation/cdmi-api/#fids_to_functions" target='_blank'>fids_to_functions</a> -c 3 &gt; role.md5.fid.genome.SEED.function.$$";<br><br>my @role_md5_funcs = sort { $a-&gt;[1] cmp $b-&gt;[1] }<br>                     map { chomp; my @tmp = split(/\t/,$_); [@tmp[0,1,5]] }<br>                     `cat role.md5.fid.genome.SEED.function.$$`;<br>&amp;make_clean_md5s(\@role_md5_funcs);<br>unlink("role.md5.$$","role.md5.fid.genome.SEED.function.$$");<br><br>sub make_clean_md5s {<br>    my($role_md5_funcs) = @_;<br><br>    while (@$role_md5_funcs &gt; 0)<br>    {<br>        my $same     = 0;<br>        my $not_same = 0;<br>        my $role = $role_md5_funcs-&gt;[0]-&gt;[0];<br>        my $md5  = $role_md5_funcs-&gt;[0]-&gt;[1];<br>        while ((@$role_md5_funcs &gt; 0) &amp;&amp; ($md5 eq $role_md5_funcs-&gt;[0]-&gt;[1]))<br>        {<br>            if ($role_md5_funcs-&gt;[0]-&gt;[0] eq $role_md5_funcs-&gt;[0]-&gt;[2])<br>            {<br>                $same++;<br>            }<br>            else<br>            {<br>                $not_same++;<br>            }<br>            shift @$role_md5_funcs;<br>        }<br><br>        if ($same &gt; $not_same)<br>        {<br>            print join("\t",($md5,$role)),"\n";<br>        }<br>    }<br>}<br><br><br></pre>
We discuss this program briefly.
The program begins by getting the roles used in constructing models:
<br><pre>system("<a href="http://kbase.us/index.php/developers/api-documentation/cdmi-api/#all_roles_used_in_models" target='_blank'>all_roles_used_in_models</a> | <a href="http://kbase.us/index.php/developers/api-documentation/cdmi-api/#roles_to_proteins" target='_blank'>roles_to_proteins</a> 2&gt; /dev/null &gt; role.md5.$$");<br><br></pre>

The vocabulary we use for constructing models is based on the SEED
vocabulary, so we consider only assertions in SEED genomes that match
this restricted set of roles.  Here we use a very simple pipeline to
get 6-tuples (<i>Role,MD5,Fid,Genome,SEED,Function</i>).  The 5th
column represents the source of the assertions, and for this exercise,
we use the Unix <i>grep</i> command to restrict the source of tuples to just 'SEED'

<br><pre>system("<a href="http://kbase.us/index.php/developers/api-documentation/cdmi-api/#proteins_to_fids" target='_blank'>proteins_to_fids</a> &lt; role.md5.$$  2&gt; /dev/null | \<br>        <a href="http://kbase.us/index.php/developers/api-documentation/cdmi-api/#fids_to_genomes" target='_blank'>fids_to_genomes</a> | \<br>        <a href="http://kbase.us/index.php/developers/api-documentation/cdmi-entity-api/#get_relationship_WasSubmittedBy" target='_blank'>get_relationship_WasSubmittedBy</a> -to id | \<br>        grep \"SEED\$\" | \<br>        <a href="http://kbase.us/index.php/developers/api-documentation/cdmi-api/#fids_to_functions" target='_blank'>fids_to_functions</a> -c 3 &gt; role.md5.fid.genome.SEED.function.$$";<br><br><br></pre>
Now, we sort the results on the <i>md5</i> field.  This groups the set of tuples
that make assertions about the same protein sequence.
<br><pre>my @role_md5_funcs = sort { $a-&gt;[1] cmp $b-&gt;[1] }<br>                     map { chomp; my @tmp = split(/\t/,$_); [@tmp[0,1,5]] }<br>                     `cat role.md5.fid.genome.SEED.function.$$`;<br><br></pre>
Finally, we need to process the groups, and for those in which a majority
are for the same function (and it matches one of the roles we are interested in)
we print out a clean md5 assertion:
<br><pre>&amp;make_clean_md5s(\@role_md5_funcs);<br><br>sub make_clean_md5s {<br>    my($role_md5_funcs) = @_;<br><br>    while (@$role_md5_funcs &gt; 0)<br>    {<br>        my $same     = 0;<br>        my $not_same = 0;<br>        my $role = $role_md5_funcs-&gt;[0]-&gt;[0];<br>        my $md5  = $role_md5_funcs-&gt;[0]-&gt;[1];<br>        while ((@$role_md5_funcs &gt; 0) &amp;&amp; ($md5 eq $role_md5_funcs-&gt;[0]-&gt;[1]))<br>        {<br>            if ($role_md5_funcs-&gt;[0]-&gt;[0] eq $role_md5_funcs-&gt;[0]-&gt;[2])<br>            {<br>                $same++;<br>            }<br>            else<br>            {<br>                $not_same++;<br>            }<br>            shift @$role_md5_funcs;<br>        }<br><br>        if ($same &gt; $not_same)<br>        {<br>            print join("\t",($md5,$role)),"\n";<br>        }<br>    }<br>}<br><br></pre>

<h3> Computing <i>Clean MD5 Assertions</i> for MOL</h3>

We provide another simple Perl script that can be used to compute the
clean md5 assertions provided by MOL.
The program we provide illustrates the use of a CS-API pipeline invoked in an <i>open</i>.
This can be a useful way to gain access to the output of a pipeline without having
to generate an intermediate file, access it, and then remove it.
<br><br> 
We suppose that the ouput of the previous program (which generated SEED clean MD5 assertions)
has been placed in the file <i>SEED-md5.func</i>.
<br><pre>open(TMP,"cut -f 1 $seed_md5_func | \<br>          <a href="http://kbase.us/index.php/developers/api-documentation/cdmi-api/#proteins_to_fids" target='_blank'>proteins_to_fids</a> 2&gt; /dev/null | \<br>          <a href="http://kbase.us/index.php/developers/api-documentation/cdmi-api/#fids_to_genomes" target='_blank'>fids_to_genomes</a> | \<br>          <a href="http://kbase.us/index.php/developers/api-documentation/cdmi-entity-api/#get_relationship_WasSubmittedBy" target='_blank'>get_relationship_WasSubmittedBy</a> -to id | \<br>          grep \"MOL\$\" | \<br>          <a href="http://kbase.us/index.php/developers/api-documentation/cdmi-api/#fids_to_functions" target='_blank'>fids_to_functions</a> -c 2 2&gt; /dev/null | \<br>          sort -k 1 | \<br>          cut -f 1,5 |")<br>    || die "could not set up the temporary pipe";<br><br>my $x = <tmp>;<br>while ($x &amp;&amp; ($x =~ /^(\S+)/))<br>{   <br>    my $md5 = $1;<br>    my %funcs;<br>    while ($x &amp;&amp; ($x =~ /^(\S+)\t(.*)/) &amp;&amp; ($1 eq $md5))<br>    {<br>        if ($2)<br>        {   <br>            $funcs{$2}++;<br>        }<br>        $x = <tmp>;<br>    }<br>    my @poss = sort { $funcs{$b} &lt;=&gt; $funcs{$a} } keys(%funcs);<br>    if ((@poss == 1) || ($funcs{$poss[0]} &gt; $funcs{$poss[1]}))<br>    {<br>        print join("\t",($md5,$poss[0])),"\n";<br>    }<br>}<br>close(TMP);<br><br><br></tmp></tmp></pre>
The program begins by "opening" a small pipeline.  The output
of this pipeline is accessed via the filehandle <b>TMP</b>.
<br><pre>open(TMP,"cut -f 1 $seed_md5_func |<br>          <a href="http://kbase.us/index.php/developers/api-documentation/cdmi-api/#proteins_to_fids" target='_blank'>proteins_to_fids</a> 2&gt; /dev/null | \<br>          <a href="http://kbase.us/index.php/developers/api-documentation/cdmi-api/#fids_to_genomes" target='_blank'>fids_to_genomes</a> | \<br>          <a href="http://kbase.us/index.php/developers/api-documentation/cdmi-entity-api/#get_relationship_WasSubmittedBy" target='_blank'>get_relationship_WasSubmittedBy</a> -to id | \<br>          grep \"MOL\$\" | \<br>          <a href="http://kbase.us/index.php/developers/api-documentation/cdmi-api/#fids_to_functions" target='_blank'>fids_to_functions</a> -c 2 2&gt; /dev/null | \<br>          sort -k 1 | \<br>          cut -f 1,5 |")<br>    || die "could not set up the temporary pipe";<br><br><br></pre>

Note that the lines provided by <b>TMP</b> each contain an md5 value
and an associated function, and the lines are sorted on the md5
values.  This allows a simple loop that accumulates function counts
for a set of lines sharing a common md5 value.  If a group has a
single common function, or if there is a single function that is more
common than any others, the loop will print out a line containing the
md5 and the most commonly occuring function.

<br><pre>my $x = <tmp>;<br>while ($x &amp;&amp; ($x =~ /^(\S+)/))<br>{   <br>    my $md5 = $1;<br>    my %funcs;<br>    while ($x &amp;&amp; ($x =~ /^(\S+)\t(.*)/) &amp;&amp; ($1 eq $md5))<br>    {<br>        if ($2)<br>        {   <br>            $funcs{$2}++;<br>        }<br>        $x = <tmp>;<br>    }<br>    my @poss = sort { $funcs{$b} &lt;=&gt; $funcs{$a} } keys(%funcs);<br>    if ((@poss == 1) || ($funcs{$poss[0]} &gt; $funcs{$poss[1]}))<br>    {<br>        print join("\t",($md5,$poss[0])),"\n";<br>    }<br>}<br><br></tmp></tmp></pre>
Suppose that the output is placed in the file MOL-md5.function.
Hence, at this point we have (md5,function) tuples for both SEED annotations (restricted
to functions corresponding to roles used in models) and MOL (here they are restricted to
md5 values that occur in the SEED tuples).  In the next step we will merge these into
matched assertions from which we can build correspondences.

<h3> Computing <i>Matched Assertions</i> from the SEED and MOL Clean MD5 Assertions</h3>

We now have two files: one containing (md5,function) 2-tuples for SEED
assertions, and a second containing (md5,function) 2-tuples for MOL
assertions. The following simple perl program produces the <i>matched
assertions</i> as 3-tuples containing
<br><pre>
  (SEED-function,md5,MOL-function):


my %SEED = map { ($_ =~ /^(\S+)\t(.*)$/) ? ($1 =&gt; $2) : () } `cat SEED-md5.function`;
my %MOL  = map { ($_ =~ /^(\S+)\t(.*)$/) ? ($1 =&gt; $2) : () } `cat MOL-md5.function`;

foreach my $md5 (sort keys(%SEED))
{
    if (defined($MOL{$md5}))
    {
        print join("\t",($SEED{$md5},$md5,$MOL{$md5})),"\n";
    }
}
<br></pre>


<h3> Integrating the Matched Assertions: an Initial Simple Approach</h3>

The 3-tuples that make up the set of matched assertions are the raw data from which
meaningful correspondences can be computed.  If we sort the 3-tuples on md5 value,
then we can programmatically determine which translations should be generated by
implementing whatever rules seem appropriate.  We suggest looking at the
output of 

<br><pre>my %SEED2MOL;<br>my %MOL2SEED;<br><br>foreach $_ (<stdin>)<br>{<br>    chomp;<br>    my($SEEDF,$md5,$MOLF) = split(/\t/,$_);<br>    $SEED2MOL{$SEEDF}-&gt;{$MOLF}++;<br>    $MOL2SEED{$MOLF}-&gt;{$SEEDF}++;<br>}<br><br>my @tots;<br>foreach my $SEEDF (keys(%SEED2MOL))<br>{<br>    my $x = $SEED2MOL{$SEEDF};<br>    my @funcs = sort { $b-&gt;[1] &lt;=&gt; $a-&gt;[1] } map { [$_,$x-&gt;{$_}] } keys(%$x);<br>    my $t = 0;<br>    foreach $_ (@funcs) { $t += $_-&gt;[1] }<br>    push(@tots,[$t,\@funcs,$SEEDF]);<br>}<br>@tots = sort { $b-&gt;[0] &lt;=&gt; $a-&gt;[0] } @tots;<br>foreach $_ (@tots)<br>{<br>    my($cnt,$funcs,$SEEDF) = @$_;<br>    print "$cnt: $SEEDF\n",join("\n",map { join("\t",reverse @$_)} @$funcs),"\n";<br>    print "//\n";<br>}<br><br></stdin></pre>
This will produce output like

<br><pre>898: DNA polymerase III alpha subunit (EC 2.7.7.7)<br>307     DNA polymerase III, alpha subunit<br>125     DNA polymerase III subunit alpha<br>92      DNA polymerase III alpha subunit<br>.<br>.<br>.<br>//<br>883: Dihydrodipicolinate synthase (EC 4.2.1.52)<br>480     dihydrodipicolinate synthase<br>105     dihydrodipicolinate synthetase<br>80      hypothetical protein<br>45      putative dihydrodipicolinate synthase<br>.<br>.<br>.<br>//<br><br><br></pre>
Each group begins with the SEED functional role.  The line displaying it includes the
count of the number of matched asssertions for the role.  Subsequent lines give
counts and functions for the corresponding MOL entries.
<p>
As you can see, with a minimal amount of effort, the appropriate data to support translations
can be extracted from data in the CS.  Actually constructing well-defined mappings will
inevitably require at least a limited amount of manual effort.  Arriving at consistent
annotations in multiple vocabularies is an achievable goal, especially if we focus on the
constrained set of functional roles used in metabolic and regulatory models.


</p></body></html>