<h1>KBase Development in the SEED Environment</h1>
<h2>Introduction</h2>
 The KBase development environment is still under construction. To accelerate progress, we have created a framework within the <a name="SEED531">SEED</a>
 environment that allows us to develop and test software, as well as creating and maintaining tutorials and documentation. At this stage, we have employed this environment to support work on the ID server, the CS and the documentation. We intend to move to a native KBase development environment, once it is well-defined. Until then, this document is intended to help KBase developers with access to the <a name="SEED532">SEED</a>
 environment to get started. To actually see documentation rendered in some format, go to the <a href="http://kbase.us/index.php/developers/developer-home/" target="_blank">KBase Developers Site</a>
. <br />
<br />
 Let us start by listing the things that a developer will need access to: <ol><li> the documentation of APIs (at this point, the the <a name="CS-API533">CS-API</a>), <li> the documentation of the command-line scripts that support access to CS data, <li> the XML specification of the <a name="CDM534">CDM</a> <a name="ER-Model535">ER-Model</a>, <li> the tutorials being developed to document data, software, and protocols (this would include documents like those defining <ul><li> the creation of MD5 hashes for KBase genomes, contigs and proteins, <li> the format for encoding genomes from external sources (sometimes loosely referred to as <i>the exchange format</i>, but there will rapidly become more data types that need &quot;exchange formats&quot;), and <li> descriptions of the type language used for defining <a name="API536">API</a> routines </ul><li> the type specifications for the <a name="CS-API537">CS-API</a> routines <li> the documentation of the type language and the compiler, <li> the source code for the <a name="CS-API538">CS-API</a> routines, <li> the source code for the CS-access command-line scripts, and <li> the source code for the examples used in the tutorials. </ol>
 We have chosen to embed the maintenance of these documents and code in an extension of the CVS structure that we use to maintain the <a name="SEED539">SEED</a>
. Thus, to get started, go to the <i>base</i>
 directory of your <a name="SEED540">SEED</a>
, which is what we call the <br />
<pre>
        .../FIGdisk/dist/releases/current
<br /></pre>
 directory. Then update your source using <br />
<pre>
        cvs co KBaseCDMI KBaseTutorials
        make
<br /></pre>
 Once this is done you can find things at the following locations: <ul><li> The XML specification of the <a name="CDM541">CDM</a> <a name="ER-Model542">ER-Model</a> can be found at <i>base/KBaseCDMI/KSaplingDBD.xml</i> (mere mortals should avoid even thinking of altering this file) <li> The <a name="CS-API543">CS-API</a> document type specifications for the &quot;well-trodden path&quot; routines are at <i>base/KBaseCDMI/CDMI-<a name="API544">API</a>.spec</i><li> The <a name="CS-API545">CS-API</a> document type specifications for the all_entities_ENTITY, get_entity_ENTITY, and get_relationship_RELATIONSHIP (which are automatically generated from the XML specifications of the <a name="CDM546">CDM</a> <a name="ER-Model547">ER-Model</a>) are at <i>base/KBaseCDMI/CDMI-EntityAPI.spec</i><li> The <a name="CS-API548">CS-API</a> source code for the &quot;well-trodden path routines&quot; is in <i>base/KBaseCDMI/Bio/KBase/CDMI/CDMI_APIImpl.pm</i><li> The <a name="CS-API549">CS-API</a> source code for the all_entities_ENTITY, get_entity_ENTITY, and get_relationship_RELATIONSHIP routines (which, again, are automatically generated) is in <i>base/KBaseCDMI/Bio/KBase/CDMI/CDMI_EntityAPIImpl.pm</i><li> The CS well-trodden paths command-line scripts and embedded documentation is in <i>base/KBaseCDMI/scripts</i><li> The CS command-line scripts source code for the all_entities_ENTITY, get_entity_ENTITY, and get_relationship_RELATIONSHIP scripts (which, again, are automatically generated) is in <i>base/KBaseCDMI/er_scripts</i><li> The tutorials and supporting code can all be found in <i>base/KBaseTutorials</i><li> The miscellaneous documentation (relating to things like the MD5 hashes, the type compiler, and the exchange format) are in <i>base/KBaseDoc</i></ul>
<br />
<hr />
<br />
 Knowing where things are is half the battle. <h2>Updating or Defining a CS-API &quot;Well-Trodden Path&quot; Routine</h2>
 There are a set (a slowly growing set) of <a name="API550">API</a>
 services that reflect &quot;well-trodden paths&quot; (a routine that creates a short-<a name="cut551">cut</a>
 through the ER-model, replacing a sequence of all_entities, get_entity, get_relationship operations). You need to <ol><li> Update the <a name="CS-API552">CS-API</a> document type specifications kept in <i>base/KBaseCDMI/CDMI-<a name="API553">API</a>.spec</i>. If you have not yet used the type compiler, we strongly recommend you work with someone who has to get started. <li> Run the type compiler. This is done with <br /><pre>
         recompile_typespec
<br /></pre> which rebuilds <br /><pre>
         <i>base/KBaseCDMI/CDMI-EntityAPI.spec</i>
         <i>base/KBaseCDMI/Bio/KBase/CDMI/CDMI_EntityAPIImpl.pm</i>
         <i>base/KBaseCDMI/er_scripts</i>
<br /></pre> These should probably not be impacted by defining a new <a name="API554">API</a> routine or maintaining a well-trodden path routine. However, <br /><pre>
<i>base/KBaseCDMI/Bio/KBase/CDMI/CDMI_APIImpl.pm</i>         
<br /></pre> will contain a new routine, and the routine is a skeletal form of the one you want. You need to flesh it out and debug it. <br /><br /> There are issues in debugging <a name="CS-API555">CS-API</a> routines that need discussing. <p> First, when you begin debugging a <a name="CS-API556">CS-API</a> routine, we recommend constructing a simple test script that invokes it. The test script should include lines similar to the following: <br /><pre>
use Data::Dumper;
use Bio::KBase::CDMI::CDMIClient;
use Bio::KBase::Utilities::ScriptThing;
my $CS_API_Obj = Bio::KBase::CDMI::CDMIClient-&gt;new_for_script();

my $results = $CS_API_Obj-&gt;rtn_name(arguments);
print STDERR &amp;Dumper($results);
<br /></pre> Then, when you run the script, <b>include the argument &quot;-local&quot; on the command line</b>. Thus, use <br /><pre>
    perl testit.pl -local
<br /></pre> This causes the code that is invoked to run locally, and you will get your normal error messages. This is a very, very good thing. <p> There is another issue that has given grief to some of us. When you are constructing a <a name="CS-API557">CS-API</a> routine, you may wish to invoke either database services (we have a powerful set of operators against the CS) or you may wish to invoke other <a name="CS-API558">CS-API</a> services. To get at the underlying CS database, use <br /><pre>
      my $CS_DB_Obj = $self-&gt;{db};
<br /></pre> This gives you access to routines like <br /><pre>
      my $result = $CS_DB_Obj-&gt;Get(...)
      my $result = $CS_DB_Obj-&gt;GetAll(...)
      my $result = $CS_DB_Obj-&gt;GetFlat(...)
<br /></pre> These are ERDB functions for accessing the data in the CS. On the other hand, if you wish to invoke another <a name="CS-API559">CS-API</a> routine, use <br /><pre>
      $self-&gt;routine(...)
<br /></pre> That is, when a <a name="CS-API560">CS-API</a> routine is invoked, the first argument (which is normally <i>self</i>), is the object that offers access to the <a name="CS-API561">CS-API</a> routines themselves. <br /><br /><li> Once you have fleshed out the routine and debugged it, you need to commit the updated version of <br /><pre>
<i>base/KBaseCDMI/Bio/KBase/CDMI/CDMI_APIImpl.pm</i>         
<br /></pre></ol>
<h2>Updating or Defining a CS Command-Line Script</h2>
 The CS command-line scripts are a little different. A skeletal form of the command can be generated, but details of arguments and function need to be manually done. This means that you do not want to just rebuild these files automatically, but it is also true that you need to get the skeletal form for a new command (and you will fix it up, put it in <br />
<pre>
<i>base/KBaseCDMI/scripts</i>
<br /></pre>
 add it to CVS, and commit it. You should spiff up the documentation before doing so. <p> To create the skeleton, you will need to move to the KBaseCDMI directory and run the command <pre>
./generate_script_skeleton function-name &gt; script_file.pl
</pre> This will give you the basic script that you will need to read through, customize, test, and update the documentation. Once that is complete you should move the script into the scripts directory and &quot;<a name="cvs562">cvs</a> add&quot; it to the repository. <br /><br />
<h2>Updating Tutorial Material</h2>
 The tutorial material is critical, at least at this initial stage of the KBase projet. When you write a tutorial, you begin by creating a directory in <br />
<pre>
       <i>base/KBaseTutorials</i>
<br /></pre>
 Then add the directory to CVS. We suggest that you look at what is there to see the pattern. You need to record the new directory in <br />
<pre>
       <i>base/KBaseTutorials/ORDER</i>
<br /></pre>
 which determines placement of the tutorial in the sidebar you see when you go to the <a href="http://kbase.us/index.php/developers/developer-home/" target="_blank">KBaseDevelopers Site</a>
. Normally, you will put just an HTML document in your new directory, add it to CVS and commit it. 