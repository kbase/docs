<html>
  <head>
  </head>
  <body>
    <h1>Towards a Controlled Vocabulary Part 3: Making the MOL Translation to the Abstract Function Vocabulary</h1> We have described how to define an abstract vocabulary of function using exemplars in <a href="http://kbase.us/developer-zone/tutorials/command-line-scripts/command-line-applications/towards-a-controlled-vocabulary-part-1-defining-exemplars/" l="l">Part 1: Defining <a name="Exemplars390">Exemplars</a></a>. Next, we described how to generate the <a name="SEED391">SEED</a> mapping from <a name="SEED392">SEED</a> ids to the abstract vocabulary imposed by exemplars <a href="http://kbase.us/developer-zone/tutorials/command-line-scripts/command-line-applications/towards-a-controlled-vocabulary-part-2-mapping-to-exemplars/">Part 2: Mapping to <a name="Exemplars393">Exemplars</a></a>. We complete this discussion of how to reach consistent <a name="annotations394">annotations</a> in an abstract vocabulary by discussing how one might map <a name="MicrobesOnLine395">MicrobesOnLine</a> (MOL) features to the abstract vocabulary. <br />
    <br /> The overall strategy is as follows: <ol>
      <li> We start with the <a name="SEED396">SEED</a> translation, represented as 4-tuples of the form <br /><pre>
           [source,source-id,fid,exemplar]
<br /></pre> where the <i>source</i> is <i><a name="SEED397">SEED</a></i>. Here, the <i>fid</i> field is the KBase ID of the <a name="SEED398">SEED</a> <i>source_id</i>. We begin by adding a column containing the <a name="md5399">md5</a> values using <br /><pre>
           <a href="http://kbase.us/developer-zone/api-documentation/cdm-command-line-scripts/#fids_to_proteins" target='_blank'>fids_to_proteins</a> -c 3 &lt; seed.translation.table &gt; seed.translation.with.md5
<br /></pre> and we <a name="sort400">sort</a> them on the <a name="md5401">md5</a> value using <br /><pre>
            sort -u -k 5 seed.translation.with.md5 &gt; sorted.seed.with.md5
<br /></pre><li> Then, we create a table of data relating to the MOL genomes using <br /><pre>
            echo MOL | 
	    <a href="http://kbase.us/developer-zone/api-documentation/cdm-entity-relationship-command-scripts/#get_relationship_Submitted" target='_blank'>get_relationship_Submitted</a> -to id | 
	    <a href="http://kbase.us/developer-zone/api-documentation/cdm-command-line-scripts/#genomes_to_fids" target='_blank'>genomes_to_fids</a> peg | 
	    cut -f 3 | 
	    <a href="http://kbase.us/developer-zone/api-documentation/cdm-entity-relationship-command-scripts/#get_entity_Feature" target='_blank'>get_entity_Feature</a> -f source_id |
	    <a href="http://kbase.us/developer-zone/api-documentation/cdm-command-line-scripts/#fids_to_proteins" target='_blank'>fids_to_proteins</a> -c 1 2&gt; /dev/null | 
	    <a href="http://kbase.us/developer-zone/api-documentation/cdm-command-line-scripts/#fids_to_functions" target='_blank'>fids_to_functions</a> -c 1 |
	    sort -k 3 &gt; MOL.fid.source_id.md5.function
<br /></pre> Now, we have two fairy large files, <i>seed.translation.with.<a name="md5402">md5</a></i> and <i>MOL.fid.<a name="md5403">md5</a>.function</i>, both sorted on <a name="md5404">md5</a> values. We can now make a single pass through the two files, compiling the data we will need to construct an initial translation file for MOL. Essentially, as we pass through the two files, we detect cases in which an MOL fid had an identical <a name="md5405">md5</a> to a <a name="SEED406">SEED</a> fid; we use this to take the corresponding exemplar and the MOL function and increment a count of the times this function occurred with that exemplar. After the pass, we simply take, for each exemplar the string that MOL most often used to describe the abstract function, and we write out a file of inconsistent sets to support MOL in detecting and correcting inconsistencies. This is accomplished by the following short perl program: <br /><pre>
#
# make_MOL_translation.pl
#
open(IN1,&quot;&lt;&quot;,&quot;MOL.fid.source_id.md5.function&quot;) || die &quot;could not open MOL.fid.source_id.md5.function&quot;;
open(IN2,&quot;&lt;&quot;,&quot;sorted.seed.with.md5&quot;)           || die &quot;could not open sorted.seed.with.md5&quot;;

my %counts;
my $row1 = &lt;IN1&gt;;
my $row2 = &lt;IN2&gt;;
my $n=1;
while ($row1 &amp;&amp; $row2)
{
    my($fid_MOL,$source_id_MOL,$md5_MOL,$function_MOL) 
	= ($row1 =~ /^(\S+)\t(\S+)\t(\S+)\t(.*)/);
    my($source_id_SEED,$exemplar,$md5_SEED) 
	= ($row2 =~ /^\S+\t(\S+)\t\S+\t(\S+)\t(\S+)/);

    if (($md5_MOL lt $md5_SEED) || &amp;hypo($function_MOL))
    {
	$row1 = &lt;IN1&gt;;
    }
    elsif ($md5_MOL gt $md5_SEED)
    {
	$row2 = &lt;IN2&gt;;
    }
    else
    {
	$counts{$exemplar}-&gt;{$function_MOL}++;
	$row1 = &lt;IN1&gt;;
    }
}
close(IN1);
close(IN2);

foreach my $exemplar (keys(%counts))
{
    my @funcs = sort { $counts{$exemplar}-&gt;{$b} &lt;=&gt; $counts{$exemplar}-&gt;{$a} } keys(%{$counts{$exemplar}});
    print join(&quot;\t&quot;,($exemplar,$funcs[0])),&quot;\n&quot;;
}

# a modest attempt to catch most hypothetical roles
#
sub hypo {
    my ($func) = @_;
    if (! $func)                             { return 1 }
    $func =~ s/\s*\#.*$//;
    if ($func =~ /lmo\d+ protein/i)          { return 1 }
    if ($func =~ /hypoth/i)                  { return 1 }
    if ($func =~ /conserved protein/i)       { return 1 }
    if ($func =~ /gene product/i)            { return 1 }
    if ($func =~ /interpro/i)                { return 1 }
    if ($func =~ /B[sl][lr]\d/i)             { return 1 }
    if ($func =~ /^U\d/)                     { return 1 }
    if ($func =~ /^orf[^_]/i)                { return 1 }
    if ($func =~ /uncharacterized/i)         { return 1 }
    if ($func =~ /pseudogene/i)              { return 1 }
    if ($func =~ /^predicted/i)              { return 1 }
    if ($func =~ /AGR_/)                     { return 1 }
    if ($func =~ /similar to/i)              { return 1 }
    if ($func =~ /similarity/i)              { return 1 }
    if ($func =~ /glimmer/i)                 { return 1 }
    if ($func =~ /unknown/i)                 { return 1 }
    if (($func =~ /domain/i) ||
        ($func =~ /^y[a-z]{2,4}\b/i) ||
        ($func =~ /complete/i) ||
        ($func =~ /ensang/i) ||
        ($func =~ /unnamed/i) ||
        ($func =~ /EG:/) ||
        ($func =~ /orf\d+/i) ||
        ($func =~ /RIKEN/) ||
        ($func =~ /Expressed/i) ||
        ($func =~ /[a-zA-Z]{2,3}\|/) ||
        ($func =~ /predicted by Psort/) ||
        ($func =~ /^bh\d+/i) ||
        ($func =~ /cds_/i) ||
        ($func =~ /^[a-z]{2,3}\d+[^:\+\-0-9]/i) ||
        ($func =~ /similar to/i) ||
        ($func =~ / identi/i) ||
        ($func =~ /\bputative\b/i) ||
        ($func =~ /ortholog of/i) ||
        ($func =~ /structural feature/i))    { return 1 }
    return 0;
}

<br /></pre> The program outputs a set of 2-tuples: <br /><pre>
           [exemplar,MOL-function]
<br /></pre> On our initial uses of the program approximately 80% of the functional roles used in modelling were included in the initial MOL tranlation table. <br />
        <br /> We have attempted to weed out hypothetical assignments from consideration. We make no attempt to identify inconsistencies in the MOL assignments. All we give is a table that maps the abstract roles (exemplars) to an MOL function that is used at least as often as any other to represent the role. </ol>
  </body>
</html>
